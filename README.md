# ML-KEM Post-Quantum Encryption Web App

**this is my pet project to learn Rust and PQC. Please don't hate me with the "quality"**

A web application demonstrating ML-KEM-768 (Module-Lattice-Based Key Encapsulation Mechanism) for quantum-resistant key exchange and secure messaging. 

MLKEM (key exchange) is implemented using Rust (WASM-Compiled) and data encryption and decryption (AAES-256-GCM) are implemented via Web Crypt API.

## Features

- **Quantum-Resistant Key Exchange**: Uses ML-KEM-768 (FIPS 203) for post-quantum secure key establishment
- **Asymmetric Key Generation**: User A generates public/private keypair
- **Key Encapsulation**: User B encapsulates a shared secret using User A's public key
- **Secure Decapsulation**: User A recovers the shared secret using their private key
- **End-to-End Encryption**: Both users can encrypt/decrypt messages using AES-256-GCM with the shared secret

## How It Works

1. **User A** generates a keypair (public key + secret key)
2. **User A** shares their public key with **User B**
3. **User B** uses the public key to encapsulate a shared secret, creating a ciphertext
4. **User B** sends the ciphertext to **User A**
5. **User A** decapsulates the ciphertext using their secret key to obtain the same shared secret
6. Both users now have the same shared secret and can encrypt/decrypt messages

## Running the Application

```bash
# Navigate to the mlkem-wasm directory
cd mlkem-wasm

# Start a simple HTTP server
python3 -m http.server 8000
```

Then open your browser to: `http://localhost:8000`

## Usage Instructions

### Step 1: Generate Keys (User A)
1. Click "Generate Keys" in the User A section
2. The public key and secret key will be displayed
3. Copy the public key (use the Copy button)

### Step 2: Share Public Key
1. Send the public key to User B (via chat, email, etc.)
2. User B pastes the public key into their input field

### Step 3: Encapsulate (User B)
1. User B clicks "Encapsulate"
2. A ciphertext and shared secret are generated
3. User B copies the ciphertext

### Step 4: Decapsulate (User A)
1. User A pastes the ciphertext into their input field
2. User A clicks "Decapsulate"
3. User A now has the same shared secret as User B

### Step 5: Secure Messaging
1. Both users can now encrypt and decrypt messages
2. Type a message and click "Encrypt"
3. Share the encrypted message
4. The recipient can paste and click "Decrypt"

## Demo Mode (Single Browser)

You can also demo this in a single browser:

1. Open the app in one browser window
2. Generate keys as User A
3. Copy the public key
4. Open the same app in a new tab/window
5. Paste as User B and continue the workflow
6. Use the shared secret to send encrypted messages between tabs

## Security Notes

⚠️ **Important**: This is a demonstration application and has not been independently audited for production use.

- ML-KEM-768 provides NIST Security Level 3 (roughly equivalent to AES-192)
- The implementation uses the `ml-kem` Rust crate (version 0.2.2)
- AES-256-GCM is used for message encryption/decryption
- Random number generation uses the browser's `crypto.getRandomValues()` and Rust's `OsRng`

## Technical Details

- **KEM**: ML-KEM-768 (formerly Kyber-768)
- **Encryption**: AES-256-GCM
- **Key Derivation**: HKDF-SHA256
- **Encoding**: Base64 for all keys and ciphertexts
- **Platform**: WebAssembly (compiled from Rust)

## Files

- `index.html` - Main HTML structure
- `app.js` - JavaScript logic and WASM integration
- `styles.css` - Styling
- `pkg/` - WASM compiled output (generated by wasm-pack)
- `src/lib.rs` - Rust WASM bindings

## Building from Source

If you need to rebuild the WASM module:

```bash
# Install wasm-pack if not already installed
curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh

# Build the WASM package
source ~/.cargo/env
wasm-pack build --target web
```

## Browser Requirements

- Modern browser with WebAssembly support
- JavaScript must be enabled

## License

This is a demonstration project. Check individual dependency licenses for production use.
